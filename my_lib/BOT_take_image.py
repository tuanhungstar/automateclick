# ... (rest of your imports in BOT_take_image.py) ...
import sys
import json
import os
import clipboard
import io
script_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(script_dir)
import base64
import PIL.Image
from PyQt6 import QtCore, QtGui, QtWidgets # Import everything needed from PyQt6
from PyQt6.QtGui import QIcon # <-- ADD THIS LINE
from PyQt6.QtWidgets import QMessageBox # Explicitly import QMessageBox for clarity
# from PyQt6.QtCore import pyqtSignal # Already imported from PyQt6.QtCore implicitly with the above line
from PIL.ImageQt import ImageQt
from pymsgbox import confirm
import pygetwindow as gw
import pyautogui
from tkinter import Tk, Toplevel, Frame, Canvas, BOTH, YES, NO, TOP, X, Y
import re # Needed for RPA step parsing if you re-add it, or for file list parsing
import time # Added this import, as it was used but not imported in Old_utility

# --- GENERATED UI CODE (from standard_gui.ui, MODIFIED to remove tabs) ---
# Form implementation generated from reading ui file 'standard_gui.ui'
#
# Created by: PyQt6 UI code generator 6.6.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
class Old_utility:
    def __int__(self):
        
        pass
    def base64_pgn(self,text):
        image_data = base64.b64decode(text)
        img_file = PIL.Image.open(io.BytesIO(image_data))    
        return img_file
    def check_item_existing(self,current_file):
    
        with open('Click_image/{}.txt'.format(current_file)) as json_file:
            image_file = json.load(json_file)
        for key, data in image_file.items():
            image_file = self.base64_pgn(data)
            location=None
            try:
                location= pyautogui.locateCenterOnScreen(image_file,grayscale=True, confidence=0.98)
            except:
                pass
            if location!=None:
                return True
        return False
    def left_click(self,current_file,offset_x=0,offset_y=0,confidence=0.92):
        
        location=None
        with open('Click_image/{}.txt'.format(current_file)) as json_file:
            image_file = json.load(json_file)
        for key, data in image_file.items():
            #print (key)
            image_file = self.base64_pgn(data)
            try:
                location= pyautogui.locateCenterOnScreen(image_file,grayscale=True, confidence=0.92)
                if location!=None:
                    pyautogui.click(location.x + offset_x, location.y + offset_y)
                    return 'left_click_done'
            except:
                pass
        if location is None:
            print ('left_click_done fail: {}'.format(current_file),str(key))
        return 'left_click_done fail: {}'.format(current_file)
    def activate_window(self,title):
        loop=0
        full_tile =''
        while title not in full_tile:
            try:
                need_avtive = gw.getWindowsWithTitle(title)[0]
                need_avtive.maximize()
                need_avtive.activate()
                full_tile = gw.getActiveWindow().title
                if title in full_tile:
                    #print(full_tile)
                    return 'done'
            except:
                #print ('try times:' , str(loop))
                loop +=1
                if loop >1000:
                    return 'fail'
    def close_window(self,title):
        loop=0
        full_tile =''
        while title not in full_tile:
            try:
                need_avtive = gw.getWindowsWithTitle(title)[0]
                need_avtive.close()
                all_window = gw.getAllTitles()
                wd_closed =None
                for each_window in all_window:
                    if title in full_tile:
                        wd_closed =False
                        break
                    else:
                        wd_closed =True
                if wd_closed==True:
                    return 'closed window'
            except:
                #print ('try times:' , str(loop))
                loop +=1
                if loop >1000 and wd_closed!=True:
                    return "Can't close {} window".format(title)   
    
    def waiting_window_close(self,window_name,timeout=5):
        '''
        Bot check if window is not exit
        return window_closed or return 'window_not_close'
        '''
        start_time = time.time()
        
        while int(time.time()-start_time) < timeout:
            all_window = gw.getAllTitles()
            result =  'window_closed'
            for each_window in all_window:
                if window_name in each_window:
                    result =  'window_not_close'
                    break # exit for look, get list of windows again
            if result !=  'window_not_close':
                return 'window_closed'  
        return 'window_not_close'
    
    def check_win_title_exits(self,title,timeout=5):
        win = None
        st = time.time()
        time_run=0
        while win is None and time_run<timeout:
            all_window = gw.getAllTitles()
            for each_window in all_window:
                if title in each_window:
                    win = each_window
            if win !=None:
                return True
            ed = time.time()
            time_run = ed-st
        return False    
    def check_image_exits(self,image_check,timeout=5):
        win = False
        st = time.time()
        time_run=0
        while win is False and time_run<timeout:
            win = self.check_item_existing(image_check)
            if win !=False:
                return True
            ed = time.time()
            time_run = ed-st
        return False        
        
    def wait_image_disappear(self,image_check,timeout=5):
        
        win = True
        st = time.time()
        time_run=0
        while win is True and time_run<timeout:
            win = self.check_item_existing(image_check)
            if win ==False:
                return True
            ed = time.time()
            time_run = ed-st
        return False 
class Ui_MainWindow_Base(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(679, 248)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tabWidget = QtWidgets.QTabWidget(parent=self.centralwidget)
        self.tabWidget.setGeometry(QtCore.QRect(0, 0, 671, 241))
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.KPI_botcomment_txt = QtWidgets.QListWidget(parent=self.tab)
        self.KPI_botcomment_txt.setGeometry(QtCore.QRect(130, 40, 231, 121))
        self.KPI_botcomment_txt.setObjectName("KPI_botcomment_txt")
        self.exit_BOT_butt = QtWidgets.QPushButton(parent=self.tab)
        self.exit_BOT_butt.setGeometry(QtCore.QRect(10, 130, 51, 28))
        self.exit_BOT_butt.setObjectName("exit_BOT_butt")
        self.Start_BOT_butt = QtWidgets.QPushButton(parent=self.tab)
        self.Start_BOT_butt.setGeometry(QtCore.QRect(10, 40, 111, 28))
        self.Start_BOT_butt.setObjectName("Start_BOT_butt")
        self.label = QtWidgets.QLabel(parent=self.tab)
        self.label.setGeometry(QtCore.QRect(50, 10, 71, 16))
        self.label.setObjectName("label")
        self.conf_list_cob_img = QtWidgets.QComboBox(parent=self.tab)
        self.conf_list_cob_img.setGeometry(QtCore.QRect(130, 10, 231, 22))
        self.conf_list_cob_img.setObjectName("conf_list_cob_img")
        self.conf_list_cob_img.addItem("")
        self.conf_list_cob_img.setItemText(0, "")
        self.click_img = QtWidgets.QLabel(parent=self.tab)
        self.click_img.setGeometry(QtCore.QRect(370, 40, 281, 91))
        self.click_img.setAutoFillBackground(True)
        self.click_img.setFrameShape(QtWidgets.QFrame.Shape.Box)
        self.click_img.setText("")
        self.click_img.setObjectName("click_img")
        self.label_2 = QtWidgets.QLabel(parent=self.tab)
        self.label_2.setGeometry(QtCore.QRect(370, 10, 101, 16))
        self.label_2.setObjectName("label_2")
        self.Test_img_butt = QtWidgets.QPushButton(parent=self.tab)
        self.Test_img_butt.setGeometry(QtCore.QRect(370, 140, 71, 28))
        self.Test_img_butt.setObjectName("Test_img_butt")
        self.Save_img_butt = QtWidgets.QPushButton(parent=self.tab)
        self.Save_img_butt.setGeometry(QtCore.QRect(10, 70, 111, 28))
        self.Save_img_butt.setObjectName("Save_img_butt")
        self.file_name_txt = QtWidgets.QTextEdit(parent=self.tab)
        self.file_name_txt.setGeometry(QtCore.QRect(130, 170, 231, 31))
        self.file_name_txt.setToolTip("")
        self.file_name_txt.setObjectName("file_name_txt")
        self.label_3 = QtWidgets.QLabel(parent=self.tab)
        self.label_3.setGeometry(QtCore.QRect(20, 180, 101, 16))
        self.label_3.setObjectName("label_3")
        self.delete_img_butt = QtWidgets.QPushButton(parent=self.tab)
        self.delete_img_butt.setGeometry(QtCore.QRect(10, 100, 111, 28))
        self.delete_img_butt.setObjectName("delete_img_butt")
        self.label_test_result = QtWidgets.QLabel(parent=self.tab)
        self.label_test_result.setGeometry(QtCore.QRect(460, 140, 181, 31))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        self.label_test_result.setFont(font)
        self.label_test_result.setText("")
        self.label_test_result.setObjectName("label_test_result")
        self.conf_list_cob_window = QtWidgets.QComboBox(parent=self.tab)
        self.conf_list_cob_window.setGeometry(QtCore.QRect(370, 170, 281, 31))
        self.conf_list_cob_window.setObjectName("conf_list_cob_window")
        self.conf_list_cob_window.addItem("")
        self.conf_list_cob_window.setItemText(0, "")
        self.tabWidget.addTab(self.tab, "") # Only the first tab remains

        # Removed 'tab_3' (RPA steps) and 'tab_2' (Config) sections

        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0) # Ensure it points to the remaining tab
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Hphung BOT"))
        self.exit_BOT_butt.setText(_translate("MainWindow", "Exit"))
        self.Start_BOT_butt.setText(_translate("MainWindow", "New Screenshot"))
        self.label.setText(_translate("MainWindow", "List of image"))
        self.label_2.setText(_translate("MainWindow", "Image"))
        self.Test_img_butt.setText(_translate("MainWindow", "Test Image"))
        self.Save_img_butt.setText(_translate("MainWindow", "Save_image"))
        self.label_3.setText(_translate("MainWindow", "Image File Name"))
        self.delete_img_butt.setText(_translate("MainWindow", "Delete image"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Screenshot"))

# --- END GENERATED UI CODE ---

# global current_pic # No longer a global; will be self.current_pic in MainWindow

# --- DummySignal (placeholder) ---
class DummySignal:
    def emit(self, *args, **kwargs):
        pass

# --- Screenshot Functions ---
def take_bounded_screenshot(x1, y1, x2, y2):
    left = min(x1, x2)
    top = min(y1, y2)
    width = abs(x2 - x1)
    height = abs(y2 - y1)

    image = pyautogui.screenshot(region=(int(left), int(top), int(width), int(height)))
    base64_image = None
    clipboard.copy('')
    if image is not None:
        image = image.convert('L') # Convert to grayscale
        buffer = io.BytesIO()
        image.save(buffer, format='PNG')
        base64_image = base64.b64encode(buffer.getvalue()).decode('utf-8')
        clipboard.copy(base64_image)
    return

def base64_pgn(text):
    image_data = base64.b64decode(text)
    img_file = PIL.Image.open(io.BytesIO(image_data))
    return img_file

def image_text_data():
    global root
    root = Tk()
    root.withdraw()
    root.title("Screenshot Tool")
    app = Screenshoot_gui(root)
    root.mainloop()
    base64_image = clipboard.paste()
    return base64_image

# --- Screenshoot_gui Class (Tkinter for screenshot) ---
class Screenshoot_gui():
    def __init__(self, master):
        clipboard.copy('')
        self.snip_surface = None
        self.master = master
        self.start_x = None
        self.start_y = None
        self.current_x = None
        self.current_y = None

        self.master_screen = Toplevel(root)
        self.master_screen.withdraw()
        self.picture_frame = Frame(self.master_screen, background="maroon3")
        self.picture_frame.pack(fill=BOTH, expand=YES)
        self.create_screen_canvas()

    def create_screen_canvas(self):
        self.master_screen.deiconify()
        root.withdraw()

        self.snip_surface = Canvas(self.picture_frame, cursor="cross", bg="grey11")
        self.snip_surface.pack(fill=BOTH, expand=YES)

        self.snip_surface.bind("<ButtonPress-1>", self.on_button_press)
        self.snip_surface.bind("<B1-Motion>", self.on_snip_drag)
        self.snip_surface.bind("<ButtonRelease-1>", self.on_button_release)

        self.master_screen.attributes('-fullscreen', True)
        self.master_screen.attributes('-alpha', .3)
        self.master_screen.lift()
        self.master_screen.attributes("-topmost", True)

    def on_button_release(self, event):
        self.current_x, self.current_y = (event.x, event.y)
        take_bounded_screenshot(self.start_x, self.start_y, self.current_x, self.current_y)

        self.exit_screenshot_mode()
        root.destroy()
        return event

    def exit_screenshot_mode(self):
        self.snip_surface.destroy()
        self.master_screen.withdraw()
        root.deiconify()

    def on_button_press(self, event):
        self.start_x = self.snip_surface.canvasx(event.x)
        self.start_y = self.snip_surface.canvasy(event.y)
        self.snip_surface.create_rectangle(0, 0, 1, 1, outline='red', width=3, fill="maroon3")

    def on_snip_drag(self, event):
        self.current_x, self.current_y = (event.x, event.y)
        self.snip_surface.coords(1, self.start_x, self.start_y, self.current_x, self.current_y)

# --- Utility Functions ---
def get_list_file(root_folder, key_word, extension):
    if not os.path.exists(root_folder):
        os.makedirs(root_folder)
        return []

    files = os.listdir(root_folder)
    file_all = []
    for file in files:
        if extension in file and key_word in file:
            file_all.append(os.path.join(root_folder, file))
    return file_all

# --- RPA Thread (QThread_Start_BOT) ---
class QThread_Start_BOT(QtCore.QThread):
    command_signal = QtCore.pyqtSignal(str) # Use QtCore.pyqtSignal

    def __init__(self, parent=None):
        super().__init__(parent)

    def thread_input(self, input_data):
        self.get_arrg = input_data

    def run(self):
        received_command = self.get_arrg
        print(received_command)
        all_step = received_command.splitlines()
        for steps in all_step:
            if not steps.strip():
                continue
            try:
                parts = steps.split(': ', 1)
                if len(parts) < 2:
                    print(f"Warning: Skipping malformed step: {steps}")
                    continue

                action_parts = parts[1].split('>>')
                if len(action_parts) < 2:
                    print(f"Warning: Skipping malformed action in step: {steps}")
                    continue

                class_name = action_parts[0].strip()
                func_and_arg = action_parts[1].strip()

                match = re.match(r'(\w+)\((.*)\)', func_and_arg)
                if not match:
                    print(f"Warning: Skipping malformed function call in step: {steps}")
                    continue

                sub_func = match.group(1)
                agr = match.group(2).strip().replace("'", "")

                # IMPORTANT: In this context, globals() might not contain your main app's classes.
                # This RPA execution is highly coupled to its own environment.
                # If these are meant to interact with your main app's modules,
                # you'd need a more sophisticated execution context passing.
                if class_name in globals() and hasattr(globals()[class_name], sub_func):
                    m = globals()[class_name]()
                    func = getattr(m, sub_func)
                    func(agr)
                else:
                    print(f"Error: Class '{class_name}' or function '{sub_func}' not found for step: {steps}")
            except Exception as e:
                print(f"Error processing RPA step '{steps}': {e}")


# --- Main Application Window Class ---
class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow_Base):
    # NEW SIGNAL: To be emitted when a screenshot is saved
    screenshotSaved = QtCore.pyqtSignal(str)

    def __init__(self, statup_image_param: str):
        super().__init__()
        self.setupUi(self)

        # --- ADD THESE LINES ---
        # Define the path relative to this script
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Goes up one level from my_lib
        icon_path = os.path.join(base_dir, "app_icon.png")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        # --- END OF ADDED LINES ---
        
        self.move(1030, 0)
        # global current_pic # Removed global
        # global img_data    # Removed global
        
        self.current_pic = '' # Initialize instance attribute
        self.img_data = {}    # Initialize instance attribute
        
        self.statup_image = statup_image_param # Store as instance attribute

        if not os.path.exists('Click_image'):
            os.makedirs('Click_image')

        file_list = get_list_file('Click_image', 'txt', 'txt')
        for file in file_list:
            base_name = os.path.basename(file)
            key = os.path.splitext(base_name)[0]
            self.conf_list_cob_img.addItem(str(key))

        # Check if startup image is already in the combo box, otherwise add it and set it
        if self.statup_image and self.conf_list_cob_img.findText(self.statup_image) == -1:
            self.conf_list_cob_img.addItem(self.statup_image)
        self.conf_list_cob_img.setCurrentText(self.statup_image)

        self.conf_list_img() # Call this after setting the current text

        all_window_titles = gw.getAllTitles()
        for each_window_title in all_window_titles:
            if len(each_window_title) > 2:
                self.conf_list_cob_window.addItem(each_window_title)

        # --- Connect UI Elements ---
        self.Start_BOT_butt.clicked.connect(self.Start_BOT)
        self.exit_BOT_butt.clicked.connect(self.exit_BOT) # This will be the closing action
        self.Save_img_butt.clicked.connect(self.Save_img)
        self.delete_img_butt.clicked.connect(self.delete_img)
        self.Test_img_butt.clicked.connect(self._test_image_actual) # Only test, not close

        self.KPI_botcomment_txt.clicked.connect(self.KPI_txt)
        self.conf_list_cob_img.currentIndexChanged.connect(self.conf_list_img)
        
        # self.show() # MainWindow in BOT_take_image.py should not call show() if it's embedded.
                     # The parent dialog (SecondWindow) will manage its visibility.

    # --- UI Slot Methods ---

    def Start_BOT(self):
        # self.current_pic # Now an instance attribute
        if self.conf_list_cob_img.currentText():
            # Using QMessageBox.question for consistent PyQt6 UI
            reply = QMessageBox.question(self, 'Check file', 'Do you want to add to current file?',
                                         QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Cancel:
                return

        # Minimize the BOT_take_image window before taking screenshot
        self.setWindowState(QtCore.Qt.WindowState.WindowMinimized)
        
        self.current_pic = image_text_data() # Update instance attribute

        # Restore the BOT_take_image window after taking screenshot
        self.setWindowState(QtCore.Qt.WindowState.WindowNoState)
        self.raise_() # Bring to front
        
        if len(self.current_pic) > 20:
            pic_png = base64_pgn(self.current_pic)
            qimage = ImageQt(pic_png)
            pixmap = QtGui.QPixmap.fromImage(qimage)
            self.click_img.setPixmap(pixmap)

    def Save_img(self):
        # self.current_pic # Now an instance attribute
        # self.img_data    # Now an instance attribute

        if len(self.current_pic) > 50:
            current_image_list_name = self.conf_list_cob_img.currentText()
            file_name = self.file_name_txt.toPlainText().strip()

            if not file_name:
                self.show_info_messagebox('Please Enter a File Name.')
                return

            # Sanitize file_name for filesystem safety
            # Remove invalid characters and replace spaces with underscores
            file_name_safe = re.sub(r'[\\/:*?"<>|]', '', file_name)
            file_name_safe = file_name_safe.replace(' ', '_')
            if not file_name_safe:
                self.show_info_messagebox('Invalid file name after sanitization. Please use alphanumeric characters, spaces, hyphens, or underscores.')
                return
            file_name = file_name_safe # Use the sanitized name

            is_adding_to_existing_combobox_item = current_image_list_name and (file_name == current_image_list_name)
            
            # --- Check for existing file / Overwrite / Add logic ---
            existing_img_files_basenames = [self.conf_list_cob_img.itemText(i) for i in range(self.conf_list_cob_img.count())]
            
            # Check if the text in the file_name_txt box is already a known file.
            # This is key for the Add/Overwrite logic.
            file_name_exists_in_combobox = file_name in existing_img_files_basenames

            if not is_adding_to_existing_combobox_item: # If the name is changing or it's a new entry
                if file_name_exists_in_combobox:
                    # File exists and is selected OR file exists and user typed its name in file_name_txt
                    reply = QMessageBox.question(self, 'File Exists', f'File "{file_name}" already exists. Do you want to "Add" to it, or "Overwrite" it?',
                                                 QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel,
                                                 QMessageBox.StandardButton.No)
                    if reply == QMessageBox.StandardButton.Cancel:
                        return
                    elif reply == QMessageBox.StandardButton.No: # Overwrite
                        self.img_data = {} # Clear existing data
                    elif reply == QMessageBox.StandardButton.Yes: # Add
                        try:
                            # Load existing data to append to it
                            with open(f'Click_image/{file_name}.txt') as json_file:
                                self.img_data = json.load(json_file)
                        except (FileNotFoundError, json.JSONDecodeError):
                            self.img_data = {} # If file exists but is empty/corrupt, start new
                else: # New file name, no conflict
                    self.img_data = {} # Start with empty data for new file
            else: # is_adding_to_existing_combobox_item is True, implying current_image_list_name == file_name
                # User selected an existing item and is saving to the same name
                # This should be treated as 'Add' by default, if it's already loaded
                if not self.img_data: # If img_data is empty, but we're adding to existing file name, load it.
                    try:
                        with open(f'Click_image/{file_name}.txt') as json_file:
                            self.img_data = json.load(json_file)
                    except (FileNotFoundError, json.JSONDecodeError):
                        self.img_data = {}


            max_idx = -1
            if self.img_data:
                for k in self.img_data.keys():
                    parts = k.rsplit('_', 1)
                    if len(parts) > 1:
                        try:
                            idx = int(parts[-1])
                            max_idx = max(max_idx, idx)
                        except ValueError:
                            pass
            new_key_idx = max_idx + 1

            new_image_key = f'{file_name}_{new_key_idx}'
            self.img_data[new_image_key] = self.current_pic

            try:
                file_path = f'Click_image/{file_name}.txt'
                with open(file_path, 'w') as outfile:
                    json.dump(self.img_data, outfile, indent=4)
                self.show_info_messagebox(f"Image saved as '{new_image_key}' in '{file_name}.txt'")

                # If the file_name was new, add it to the combobox
                if not file_name_exists_in_combobox:
                    self.conf_list_cob_img.addItem(file_name)
                    
                self.conf_list_cob_img.setCurrentText(file_name) # Ensure this is selected
                self.conf_list_img() # Refresh the list widget with newly added image
                self.KPI_botcomment_txt.setCurrentRow(self.KPI_botcomment_txt.count() - 1)
                
                # Emit signal that a screenshot was saved
                self.screenshotSaved.emit(file_name) # Emit the base filename

            except Exception as e:
                self.show_info_messagebox(f"Error saving image: {e}")
        else:
            self.show_info_messagebox('No image data to save. Take a screenshot first.')

    def delete_img(self):
        # self.current_pic # Now an instance attribute
        # self.img_data    # Now an instance attribute
        selected_item = self.KPI_botcomment_txt.currentItem()
        if not selected_item:
            self.show_info_messagebox('No image selected to delete.')
            return

        item_key_to_delete = selected_item.text()
        file_name = self.conf_list_cob_img.currentText()
        if not file_name:
            self.show_info_messagebox('No image file selected.')
            return

        reply = QMessageBox.question(self, 'Delete Image', f'Do you want to delete "{item_key_to_delete}" from "{file_name}.txt"?',
                                     QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel)
        if reply == QMessageBox.StandardButton.Ok:
            if item_key_to_delete in self.img_data:
                del self.img_data[item_key_to_delete]
                self.KPI_botcomment_txt.takeItem(self.KPI_botcomment_txt.row(selected_item))

                try:
                    if self.img_data:
                        with open(f'Click_image/{file_name}.txt', 'w') as outfile:
                            json.dump(self.img_data, outfile, indent=4)
                        self.show_info_messagebox(f"Image '{item_key_to_delete}' deleted successfully.")
                        if self.KPI_botcomment_txt.count() > 0:
                            self.KPI_botcomment_txt.setCurrentRow(0)
                            self.KPI_txt()
                        else: # If all images are deleted from a file
                            self.current_pic = '' # Clear current pic
                            self.click_img.clear() # Clear image display
                            # Signal to main GUI that the current image is gone or needs refreshing
                            self.screenshotSaved.emit("") # Emit empty string to indicate change
                    else: # If img_data became empty, remove the file
                        os.remove(f'Click_image/{file_name}.txt')
                        self.show_info_messagebox(f"Image '{item_key_to_delete}' deleted and file '{file_name}.txt' removed as it is now empty.")
                        self.current_pic = ''
                        self.click_img.clear()
                        idx = self.conf_list_cob_img.findText(file_name)
                        if idx != -1:
                            self.conf_list_cob_img.removeItem(idx)
                            if self.conf_list_cob_img.count() > 0:
                                self.conf_list_cob_img.setCurrentIndex(0)
                                self.screenshotSaved.emit(self.conf_list_cob_img.currentText()) # Emit the new current selection
                            else:
                                self.conf_list_cob_img.setCurrentText("") # No more items
                                self.screenshotSaved.emit("") # No file left
                            self.conf_list_img() # Refresh
                except OSError as e:
                    self.show_info_messagebox(f"Error removing file '{file_name}.txt': {e}")
                except Exception as e:
                    self.show_info_messagebox(f"Error saving updated image file: {e}")
            else:
                self.show_info_messagebox('Selected image not found in data.')

    def conf_list_img(self):
        self.KPI_botcomment_txt.clear()
        current_file_name = self.conf_list_cob_img.currentText()
        self.label_test_result.setText('')
        # self.current_pic # Now an instance attribute
        # self.img_data    # Now an instance attribute

        if current_file_name:
            try:
                with open(f'Click_image/{current_file_name}.txt') as json_file:
                    self.img_data = json.load(json_file) # Update instance attribute
                if self.img_data:
                    for imge_name, data in self.img_data.items():
                        self.KPI_botcomment_txt.addItem(imge_name)
                    first_key = list(self.img_data.keys())[0] if self.img_data else None
                    if first_key:
                        pic_png = base64_pgn(self.img_data[first_key])
                        qimage = ImageQt(pic_png)
                        pixmap = QtGui.QPixmap.fromImage(qimage)
                        self.click_img.setPixmap(pixmap)
                        self.current_pic = self.img_data[first_key] # Update instance attribute
                        items = self.KPI_botcomment_txt.findItems(first_key, QtCore.Qt.MatchFlag.MatchExactly)
                        if items:
                            self.KPI_botcomment_txt.setCurrentItem(items[0])
                else:
                    self.click_img.clear()
                    self.current_pic = ''
            except FileNotFoundError:
                self.show_info_messagebox(f"Image file '{current_file_name}.txt' not found.")
                self.img_data = {}
                self.click_img.clear()
                self.current_pic = ''
            except json.JSONDecodeError:
                self.show_info_messagebox(f"Error decoding JSON from '{current_file_name}.txt'. File might be corrupted.")
                self.img_data = {}
                self.click_img.clear()
                self.current_pic = ''
        else:
            self.KPI_botcomment_txt.clear()
            self.click_img.clear()
            self.current_pic = ''
        self.file_name_txt.setText(current_file_name)

    def KPI_txt(self):
        # self.img_data # Now an instance attribute
        # self.current_pic # Now an instance attribute
        selected_item = self.KPI_botcomment_txt.currentItem()
        self.label_test_result.setText('')

        if selected_item:
            item_key = selected_item.text()
            if item_key in self.img_data:
                self.current_pic = self.img_data[item_key]
                pic_png = base64_pgn(self.current_pic)
                qimage = ImageQt(pic_png)
                pixmap = QtGui.QPixmap.fromImage(qimage)
                self.click_img.setPixmap(pixmap)
            else:
                self.show_info_messagebox(f"Image data for key '{item_key}' not found.")
                self.click_img.clear()
                self.current_pic = ''
        else:
            self.click_img.clear()
            self.current_pic = ''

    def _test_image_actual(self): # Renamed the actual test logic
        # self.current_pic # Now an instance attribute
        if len(self.current_pic) > 50:
            status = self.text_located(self.current_pic)
            if status is not None:
                self.label_test_result.setText('Image Found')
            else:
                self.label_test_result.setText('Image NOT Found')
        else:
            self.label_test_result.setText('No image data to test.')

    def text_located(self, im_base64_string):
        img_file = base64_pgn(im_base64_string)
        location = None
        try:
            # Using original image in `locateCenterOnScreen` is better than converting to grayscale
            # unless images are specifically stored grayscale. The `convert('L')` in take_bounded_screenshot
            # already makes it grayscale. So, using `img_file` directly is fine here.
            location = pyautogui.locateCenterOnScreen(img_file, confidence=0.9)
        except Exception as e:
            print(f"Error during image location: {e}")
            pass
        if location is not None:
            pyautogui.moveTo(location.x, location.y)
        return location

    def exit_BOT(self):
        current_file_name = self.file_name_txt.toPlainText().strip()
        # Emit the screenshotSaved signal just before closing
        self.screenshotSaved.emit(current_file_name if current_file_name else "")
        self.close()

    def show_bot_comment(self, val):
        self.KPI_botcomment_txt.addItem(str(val))
        self.KPI_botcomment_txt.scrollToBottom()

    def show_info_messagebox(self, text, title="Information"):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Icon.Information)
        msg.setText(text)
        msg.setWindowTitle(title)
        msg.setStandardButtons(QMessageBox.StandardButton.Ok)
        return msg.exec()


if __name__ == "__main__":
    # Example usage for standalone testing
    app = QtWidgets.QApplication(sys.argv)
    # When running standalone, you need a dummy startup image name
    ex = MainWindow('default_screenshot') 
    sys.exit(app.exec())
    
